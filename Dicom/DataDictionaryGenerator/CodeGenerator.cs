#region License

// Copyright (c) 2013, ClearCanvas Inc.
// All rights reserved.
// http://www.clearcanvas.ca
//
// This file is part of the ClearCanvas RIS/PACS open source project.
//
// The ClearCanvas RIS/PACS open source project is free software: you can
// redistribute it and/or modify it under the terms of the GNU General Public
// License as published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// The ClearCanvas RIS/PACS open source project is distributed in the hope that it
// will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
// Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// the ClearCanvas RIS/PACS open source project.  If not, see
// <http://www.gnu.org/licenses/>.

#endregion

using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Resources;
using System.Xml;

namespace ClearCanvas.Dicom.DataDictionaryGenerator
{
	public class CodeGenerator
	{
		private readonly SortedList<uint, Tag> _tagList = null;
		private readonly SortedList _tSyntaxList = null;
		private readonly SortedList _sopList = null;
		private readonly SortedList _metaSopList = null;
		private readonly XmlDocument _transferSyntaxDoc = null;
		//private readonly XmlDocument _sopClassDoc;`

		public CodeGenerator(SortedList<uint, Tag> tags, SortedList tSyntax, SortedList sops, SortedList metaSops, XmlDocument transferSyntaxDoc/*, XmlDocument sopClassDoc*/)
		{
			_tagList = tags;
			_tSyntaxList = tSyntax;
			_sopList = sops;
			_metaSopList = metaSops;
			_transferSyntaxDoc = transferSyntaxDoc;
			//_sopClassDoc = sopClassDoc;
		}

		private void WriterHeader(StreamWriter writer)
		{
			var assembly = typeof (CodeGenerator).Assembly;
			var resourceName = assembly.GetManifestResourceNames().First(n => n.Contains("License.txt"));
			string license = null;

			using (var stream = assembly.GetManifestResourceStream(resourceName))
			{
				using (var reader = new StreamReader(stream))
				{
					license = reader.ReadToEnd();
				}
			}
			license = license.Replace("$year$", DateTime.Now.Year.ToString(CultureInfo.InvariantCulture));
			writer.WriteLine(license);
			writer.WriteLine("");
			writer.WriteLine("using System;");
			writer.WriteLine("using System.Collections.Generic;");
			writer.WriteLine("using System.Linq;");
			writer.WriteLine("using ClearCanvas.Common;"); 
			writer.WriteLine("");
			writer.WriteLine("// This file is auto-generated by the ClearCanvas.Dicom.DataDictionaryGenerator project.");
			writer.WriteLine("");
			writer.WriteLine("namespace ClearCanvas.Dicom");
			writer.WriteLine("{");
		}

		private void WriterFooter(StreamWriter writer)
		{
			writer.WriteLine("}");
		}

		/// <summary>
		/// Create the DicomTags.cs file.
		/// </summary>
		/// <param name="tagFile"></param>
		public void WriteTags(String tagFile)
		{
			var writer = new StreamWriter(tagFile);

			WriterHeader(writer);

			writer.WriteLine("    /// <summary>");
			writer.WriteLine("    /// This structure contains defines for all DICOM tags.");
			writer.WriteLine("    /// </summary>");
			writer.WriteLine("    public struct DicomTags");
			writer.WriteLine("    {");

			IEnumerator<Tag> iter = _tagList.Values.GetEnumerator();

			while (iter.MoveNext())
			{
				Tag tag = iter.Current;

				writer.WriteLine("        /// <summary>");
				writer.WriteLine("        /// <para>" + tag.tag + " " + tag.unEscapedName + "</para>");
				writer.WriteLine("        /// <para> VR: " + tag.vr + " VM:" + tag.vm + "</para>");
				if (tag.retired != null && tag.retired.Equals("RET"))
					writer.WriteLine("        /// <para>This tag has been retired.</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public const uint " + tag.varName + " = " + tag.nTag + ";");
			}

			writer.WriteLine("    }");
			WriterFooter(writer);

			writer.Close();
		}

		/// <summary>
		/// Get transfer syntax details from the TransferSyntax.xml file for a specific transfer syntax.
		/// </summary>
		/// <param name="uid"></param>
		/// <param name="littleEndian"></param>
		/// <param name="encapsulated"></param>
		/// <param name="explicitVR"></param>
		/// <param name="deflated"></param>
		/// <param name="lossy"></param>
		/// <param name="lossless"></param>
		public void GetTransferSyntaxDetails(String uid, ref String littleEndian, ref String encapsulated,
		                                     ref String explicitVR, ref String deflated, ref string lossy, ref string lossless)
		{
			XmlNode syntaxNode = _transferSyntaxDoc.FirstChild;

			// I know the format, just do a quick traversal to the first TransferSyntax entry
			syntaxNode = syntaxNode.NextSibling;
			syntaxNode = syntaxNode.FirstChild;

			while (syntaxNode != null)
			{
				if (syntaxNode.Name.Equals("TransferSyntax"))
				{
					String xmlUid = syntaxNode.Attributes["uid"].Value;

					if (xmlUid.Equals(uid))
					{
						littleEndian = syntaxNode.Attributes["littleEndian"].Value;
						encapsulated = syntaxNode.Attributes["encapsulated"].Value;
						explicitVR = syntaxNode.Attributes["explicitVR"].Value;
						deflated = syntaxNode.Attributes["deflated"].Value;
						lossy = syntaxNode.Attributes["lossy"].Value;
						lossless = syntaxNode.Attributes["lossless"].Value;
						return;
					}
				}
				syntaxNode = syntaxNode.NextSibling;
			}
		}

		public void GetSopClassDetails(SopClass sopClass, out string category)
		{
			//I started out using an xml document to store this information, but it wasn't worth it.
			//As it turns out, there's a fairly reliable formula based on SOP class names.
			if (sopClass.IsImage)
				category = "SopClassCategory.Image";
			else if (sopClass.IsStorage)
				category = "SopClassCategory.Storage";
			else
				category = "SopClassCategory.Uncategorized";
			
			/*
			XmlNode sopClassNode = _sopClassDoc.FirstChild;

			sopClassNode = sopClassNode.NextSibling;
			sopClassNode = sopClassNode.FirstChild;

			while (sopClassNode != null)
			{
				if (sopClassNode.Name.Equals("SopClass"))
				{
					String xmlUid = sopClassNode.Attributes["uid"].Value;

					if (xmlUid.Equals(uid))
					{
						isImage = sopClassNode.Attributes["isImage"].Value;
						return;
					}
				}
				sopClassNode = sopClassNode.NextSibling;
			}

			if (name.ToLower().Contains("Image Storage"))
				isImage = "true";
		*/
		}

		/// <summary>
		/// Create the TransferSyntax.cs file.
		/// </summary>
		/// <param name="syntaxFile"></param>
		public void WriteTransferSyntaxes(String syntaxFile)
		{
			var writer = new StreamWriter(syntaxFile);

			WriterHeader(writer);
            writer.WriteLine("    /// <summary>");
            writer.WriteLine("    /// Enumerated value to differentiate between little and big endian.");
            writer.WriteLine("    /// </summary>");
            writer.WriteLine("    public enum Endian");
            writer.WriteLine("    {");
            writer.WriteLine("        Little,");
            writer.WriteLine("        Big");
            writer.WriteLine("    }");
            writer.WriteLine("");

            writer.WriteLine("    /// <summary>");
            writer.WriteLine("    /// This class contains transfer syntax definitions.");
            writer.WriteLine("    /// </summary>");
            writer.WriteLine("    public class TransferSyntax");
            writer.WriteLine("    {");

			IEnumerator iter = _tSyntaxList.GetEnumerator();

			while (iter.MoveNext())
			{
				var tSyntax = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("        /// <summary>String representing");
				writer.WriteLine("        /// <para>" + tSyntax.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + tSyntax.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly String " + tSyntax.VarName + "Uid = \"" + tSyntax.Uid + "\";");
				writer.WriteLine("");

				String littleEndian = "";
				String encapsulated = "";
				String explicitVR = "";
				String deflated = "";
				String lossless = "";
				string lossy = "";

				GetTransferSyntaxDetails(tSyntax.Uid, ref littleEndian, ref encapsulated, ref explicitVR, ref deflated, ref lossy, ref lossless);

				writer.WriteLine("        /// <summary>TransferSyntax object representing");
				writer.WriteLine("        /// <para>" + tSyntax.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + tSyntax.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly TransferSyntax " + tSyntax.VarName + " =");
				writer.WriteLine("                    new TransferSyntax(\"" + tSyntax.Name + "\",");
				writer.WriteLine("                                 " + tSyntax.VarName + "Uid,");
				writer.WriteLine("                                 " + littleEndian + ", // Little Endian?");
				writer.WriteLine("                                 " + encapsulated + ", // Encapsulated?");
				writer.WriteLine("                                 " + explicitVR + ", // Explicit VR?");
				writer.WriteLine("                                 " + deflated + ", // Deflated?");
				writer.WriteLine("                                 " + lossy + ", // lossy?");
				writer.WriteLine("                                 " + lossless + " // lossless?");
				writer.WriteLine("                                 );");
				writer.WriteLine("");
			}

			writer.WriteLine("        // Internal members");
			writer.WriteLine("        private static readonly Dictionary<String,TransferSyntax> _transferSyntaxes = new Dictionary<String,TransferSyntax>();");
			writer.WriteLine("        private static readonly Dictionary<String,TransferSyntax> _privateTransferSyntaxes = new Dictionary<String,TransferSyntax>();");
			writer.WriteLine("        private readonly bool _littleEndian;");
			writer.WriteLine("        private readonly bool _encapsulated;");
			writer.WriteLine("        private readonly bool _explicitVr;");
			writer.WriteLine("        private readonly bool _deflate;");
			writer.WriteLine("        private readonly bool _lossless;");
			writer.WriteLine("        private readonly bool _lossy;");
			writer.WriteLine("        private readonly String _name;");
			writer.WriteLine("        private readonly String _uid;");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>");
			writer.WriteLine("        /// Constructor for transfer syntax objects");
			writer.WriteLine("        ///</summary>");
			writer.WriteLine("        public TransferSyntax(String name, String uid, bool bLittleEndian, bool bEncapsulated, bool bExplicitVr, bool bDeflate, bool bLossy, bool bLossless)");
			writer.WriteLine("        {");
			writer.WriteLine("            _uid = uid;");
			writer.WriteLine("            _name = name;");
			writer.WriteLine("            _littleEndian = bLittleEndian;");
			writer.WriteLine("            _encapsulated = bEncapsulated;");
			writer.WriteLine("            _explicitVr = bExplicitVr;");
			writer.WriteLine("            _deflate = bDeflate;");
			writer.WriteLine("            _lossy = bLossy;");
			writer.WriteLine("            _lossless = bLossless;");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Override to the ToString() method, returns the name of the transfer syntax.</summary>");
			writer.WriteLine("        public override String ToString()");
			writer.WriteLine("        {");
			writer.WriteLine("            return _name;");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing the UID string of transfer syntax.</summary>");
			writer.WriteLine("        public String UidString");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _uid; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing the DicomUid of the transfer syntax.</summary>");
			writer.WriteLine("        public DicomUid DicomUid");
			writer.WriteLine("        {");
			writer.WriteLine("            get");
			writer.WriteLine("            {");
			writer.WriteLine("                return new DicomUid(_uid, _name, UidType.TransferSyntax);");
			writer.WriteLine("            }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing the name of the transfer syntax.</summary>");
			writer.WriteLine("        public String Name");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _name; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is encoded as little endian.</summary>");
			writer.WriteLine("        public bool LittleEndian");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _littleEndian; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing the Endian enumerated value for the transfer syntax.</summary>");
			writer.WriteLine("        public Endian Endian");
			writer.WriteLine("        {");
			writer.WriteLine("            get");
			writer.WriteLine("            {");
			writer.WriteLine("                if (_littleEndian)");
			writer.WriteLine("                    return Endian.Little;");
			writer.WriteLine("");
			writer.WriteLine("                return Endian.Big;");
			writer.WriteLine("            }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is encoded as encapsulated.</summary>");
			writer.WriteLine("        public bool Encapsulated");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _encapsulated; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is a lossy compression syntax.</summary>");
			writer.WriteLine("        public bool LossyCompressed");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _lossy; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is a lossless compression syntax.</summary>");
			writer.WriteLine("        public bool LosslessCompressed");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _lossless; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is encoded as explicit Value Representation.</summary>");
			writer.WriteLine("        public bool ExplicitVr");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _explicitVr; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        ///<summary>Property representing if the transfer syntax is encoded in deflate format.</summary>");
			writer.WriteLine("        public bool Deflate");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _deflate; }");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        /// <summary>");
			writer.WriteLine("        /// Gets the <see cref=\"TransferSyntax\"/> instance for a specific transfer syntax UID.");
			writer.WriteLine("        /// </summary>");
			writer.WriteLine("        public static TransferSyntax GetTransferSyntax(String uid)");
			writer.WriteLine("        {");
			writer.WriteLine("            TransferSyntax theSyntax;");
			writer.WriteLine("            if (!_transferSyntaxes.TryGetValue(uid, out theSyntax) && !_privateTransferSyntaxes.TryGetValue(uid, out theSyntax))");
			writer.WriteLine("                return null;");
			writer.WriteLine("");
			writer.WriteLine("            return theSyntax;");
			writer.WriteLine("        }");
			writer.WriteLine("");


			writer.WriteLine("        /// <summary>");
			writer.WriteLine("        /// Enumerates all registered transfer syntaxes.");
			writer.WriteLine("        /// </summary>");
			writer.WriteLine("        public static IEnumerable<TransferSyntax> TransferSyntaxes");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _transferSyntaxes.Values.Concat(_privateTransferSyntaxes.Values); }");
			writer.WriteLine("        }");
			writer.WriteLine();
			writer.WriteLine("        /// <summary>");
			writer.WriteLine("        /// Enumerates all registered transfer syntax UIDs.");
			writer.WriteLine("        /// </summary>");
			writer.WriteLine("        public static IEnumerable<string> TransferSyntaxUids");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _transferSyntaxes.Keys.Concat(_privateTransferSyntaxes.Keys); }");
			writer.WriteLine("        }");
			writer.WriteLine();
			writer.WriteLine("        /// <summary>");
			writer.WriteLine("        /// Registers a private transfer syntax.");
			writer.WriteLine("        /// </summary>");
			writer.WriteLine("        /// <param name=\"transferSyntax\">The private transfer syntax to reigster.</param>");
			writer.WriteLine("        public static void RegisterTransferSyntax(TransferSyntax transferSyntax)");
			writer.WriteLine("        {");
			writer.WriteLine("            Platform.CheckForNullReference(transferSyntax, \"transferSyntax\");");
			writer.WriteLine("            Platform.CheckTrue(!_transferSyntaxes.ContainsKey(transferSyntax.UidString), \"Cannot redefine a standard transfer syntax.\");");
			writer.WriteLine("            Platform.CheckTrue(!_privateTransferSyntaxes.ContainsKey(transferSyntax.UidString), \"The specified private transfer syntax UID is already defined.\");");
			writer.WriteLine("            _privateTransferSyntaxes.Add(transferSyntax.UidString, transferSyntax);");
			writer.WriteLine("        }");
			writer.WriteLine();
			writer.WriteLine("        /// <summary>");
			writer.WriteLine("        /// Unregisters a private transfer syntax.");
			writer.WriteLine("        /// </summary>");
			writer.WriteLine("        /// <param name=\"transferSyntax\">The private transfer syntax to unreigster.</param>");
			writer.WriteLine("        public static void UnregisterTransferSyntax(TransferSyntax transferSyntax)");
			writer.WriteLine("        {");
			writer.WriteLine("            Platform.CheckForNullReference(transferSyntax, \"transferSyntax\");");
			writer.WriteLine("            _privateTransferSyntaxes.Remove(transferSyntax.UidString);");
			writer.WriteLine("        }");

			writer.WriteLine("        static TransferSyntax()");
			writer.WriteLine("        {");

			iter = _tSyntaxList.GetEnumerator();

			while (iter.MoveNext())
			{
				var tSyntax = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("            _transferSyntaxes.Add(" + tSyntax.VarName + "Uid,");
				writer.WriteLine("                                  " + tSyntax.VarName + ");");
				writer.WriteLine("");
			}

			writer.WriteLine("        }");

			writer.WriteLine("    }");
			WriterFooter(writer);

			writer.Close();
		}

		/// <summary>
		/// Create the SopClass.cs file.
		/// </summary>
		/// <param name="sopsFile"></param>
		public void WriteSqlInsert(String sopsFile)
		{
			var writer = new StreamWriter(sopsFile);

			WriterHeader(writer);

			IEnumerator iter = _sopList.GetEnumerator();

			while (iter.MoveNext())
			{
				var sopClass = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("INSERT INTO [ImageServer].[dbo].[SopClass] ([GUID],[SopClassUid],[Description],[NonImage])");
				if (sopClass.Name.ToLower().Contains("image"))
					writer.WriteLine("VALUES (newid(), '" + sopClass.Uid + "', '" + sopClass.Name + "', 0);");
				else
					writer.WriteLine("VALUES (newid(), '" + sopClass.Uid + "', '" + sopClass.Name + "', 1);");
				writer.WriteLine("");

			}


			writer.Close();
		}

		public void WriteTagsText(String tagsFile)
		{
			var writer = new StreamWriter(tagsFile);

			writer.WriteLine("# Copyright (c) 2012, ClearCanvas Inc.");
			writer.WriteLine("# All rights reserved.");
			writer.WriteLine("# http://www.clearcanvas.ca");
			writer.WriteLine("#");
			writer.WriteLine("# generated from DICOM standard");
			writer.WriteLine("# columns are in the same order as parameters to the DicomTag constructor");
			writer.WriteLine("# eg. tag;name;varName;vr;isMultiVrTag;vmLow;vmHigh;isRetired");
			writer.WriteLine("#");

			IEnumerator<Tag> iter = _tagList.Values.GetEnumerator();

			while (iter.MoveNext())
			{
				Tag tag = iter.Current;
				uint vmLow = 0;
				uint vmHigh = 0;
				var charSeparators = new[] {'�', '-'};

				String[] nodes = tag.vm.Split(charSeparators, StringSplitOptions.RemoveEmptyEntries);
				if (nodes.Length == 1)
				{
					vmLow = uint.Parse(nodes[0]);
					vmHigh = vmLow;
				}
				else if (nodes.Length == 2)
				{
					if (nodes[0].Contains("N") || nodes[0].Contains("n"))
					{
						vmLow = 1;
					}
					else
					{
						vmLow = uint.Parse(nodes[0]);
					}
					if (nodes[1].Contains("N") || nodes[1].Contains("n"))
					{
						vmHigh = UInt32.MaxValue;
					}
					else
					{
						vmHigh = uint.Parse(nodes[1]);
					}
				}
				string vr;
				bool isMultiVrTag;
				if (tag.vr.Contains("or"))
				{
					if (tag.varName.Equals("PixelData"))
					{
						vr = "OW";
						isMultiVrTag = true;
					}
					else
					{
						// Just take the first VR listed
						vr = tag.vr.Substring(0, 2);
						isMultiVrTag = true;
					}
				}
				else
				{
					vr = tag.vr;
					isMultiVrTag = false;
				}
				writer.WriteLine("{0};{1};{2};{3};{4};{5};{6};{7}",
				                 tag.nTag, tag.unEscapedName, tag.varName, vr, isMultiVrTag, vmLow, vmHigh, !string.IsNullOrEmpty(tag.retired));
			}

			writer.Close();
		}

		/// <summary>
		/// Create the SopClass.cs file.
		/// </summary>
		/// <param name="sopsFile"></param>
		public void WriteSopClasses(String sopsFile)
		{
			var writer = new StreamWriter(sopsFile);

			WriterHeader(writer);

			writer.WriteLine("    /// <summary>");
			writer.WriteLine("    /// Categorizations for special types of SOP classes.");
			writer.WriteLine("    /// </summary>");
			writer.WriteLine("    [Flags]");
			writer.WriteLine("    public enum SopClassCategory");
			writer.WriteLine("    {");
			writer.WriteLine("        Uncategorized = 0,");
			writer.WriteLine("        Meta = 0x1,");
			writer.WriteLine("        Storage = 0x2,");
			writer.WriteLine("        Image = 0x4 | Storage"); 
			writer.WriteLine("    }");

			writer.WriteLine("    /// <summary>");
			writer.WriteLine("    /// This class contains defines for all DICOM SOP Classes.");
			writer.WriteLine("    /// </summary>");
			writer.WriteLine("    public class SopClass");
			writer.WriteLine("    {");

			IEnumerator iter = _sopList.GetEnumerator();

			while (iter.MoveNext())
			{
				var sopClass = (SopClass) ((DictionaryEntry) iter.Current).Value;

				string category;
				GetSopClassDetails(sopClass, out category);

				writer.WriteLine("        /// <summary>");
				writer.WriteLine("        /// <para>" + sopClass.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + sopClass.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly String " + sopClass.VarName + "Uid = \"" + sopClass.Uid + "\";");
				writer.WriteLine("");
				writer.WriteLine("        /// <summary>SopClass for");
				writer.WriteLine("        /// <para>" + sopClass.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + sopClass.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly SopClass " + sopClass.VarName + " =");
				writer.WriteLine("                             new SopClass(\"" + sopClass.Name + "\", ");
				writer.WriteLine("                                          " + sopClass.VarName + "Uid, ");
				writer.WriteLine("                                          " + category + ");");
				writer.WriteLine("");
			}

			iter = _metaSopList.GetEnumerator();

			while (iter.MoveNext())
			{
				var sopClass = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("        /// <summary>String UID for");
				writer.WriteLine("        /// <para>" + sopClass.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + sopClass.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly String " + sopClass.VarName + "Uid = \"" + sopClass.Uid + "\";");
				writer.WriteLine("");
				writer.WriteLine("        /// <summary>SopClass for");
				writer.WriteLine("        /// <para>" + sopClass.Name + "</para>");
				writer.WriteLine("        /// <para>UID: " + sopClass.Uid + "</para>");
				writer.WriteLine("        /// </summary>");
				writer.WriteLine("        public static readonly SopClass " + sopClass.VarName + " =");
				writer.WriteLine("                             new SopClass(\"" + sopClass.Name + "\", ");
				writer.WriteLine("                                          " + sopClass.VarName + "Uid, ");
				writer.WriteLine("                                          SopClassCategory.Meta);");
			}


			/*
			 * Now, write out the constructor and the actual class
			 */
			writer.WriteLine("");
			writer.WriteLine("        private readonly String _sopName;");
			writer.WriteLine("        private readonly String _sopUid;");
			writer.WriteLine("        private readonly SopClassCategory _category;");
			writer.WriteLine("");
			writer.WriteLine("        /// <summary> Property that represents the Name of the SOP Class. </summary>");
			writer.WriteLine("        public String Name");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _sopName; }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Property that represents the Uid for the SOP Class. </summary>");
			writer.WriteLine("        public String Uid");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return _sopUid; }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Property that returns a DicomUid that represents the SOP Class. </summary>");
			writer.WriteLine("        public DicomUid DicomUid");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return new DicomUid(_sopUid,_sopName, Meta ? UidType.MetaSOPClass : UidType.SOPClass); }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Indicates whether or not this is a meta SOP Class. </summary>");
			writer.WriteLine("        public bool Meta");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return (_category & SopClassCategory.Meta) == SopClassCategory.Meta; }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Indicates whether or not this is a storage SOP Class. </summary>");
			writer.WriteLine("        public bool IsStorage");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return (_category & SopClassCategory.Storage) == SopClassCategory.Storage; }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Indicates whether or not this SOP Class is an image. </summary>");
			writer.WriteLine("        /// <remarks> At least where this property is concerned, an image is one that makes use of the Pixel Data (7FE0,0010)");
			writer.WriteLine("        /// attribute to encode one or more 2-D image frames that can be rendered without special processing.");
			writer.WriteLine("        /// Although some SOP Classes, like waveforms (ECG, audio), are usually represented as images or videos,");
			writer.WriteLine("        /// they are not actually images from an encoding perspective. </remarks>");
			writer.WriteLine("        public bool IsImage");
			writer.WriteLine("        {");
			writer.WriteLine("            get { return (_category & SopClassCategory.Image) == SopClassCategory.Image; }");
			writer.WriteLine("        }");
			writer.WriteLine("        /// <summary> Constructor to create SopClass object. </summary>");
			writer.WriteLine("        [Obsolete(\"Use the constructor that takes a SopClassCategory instead.\")]");
			writer.WriteLine("        public SopClass(String name,");
			writer.WriteLine("                           String uid,");
			writer.WriteLine("                           bool isMeta)");
			writer.WriteLine("             : this(name, uid, isMeta ? SopClassCategory.Meta : SopClassCategory.Uncategorized)");
			writer.WriteLine("        {");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        /// <summary> Constructor to create SopClass object. </summary>");
			writer.WriteLine("        public SopClass(String name,");
			writer.WriteLine("                           String uid,");
			writer.WriteLine("                           SopClassCategory category)");
			writer.WriteLine("        {");
			writer.WriteLine("            _sopName = name;");
			writer.WriteLine("            _sopUid = uid;");
			writer.WriteLine("            _category = category;");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        private static readonly Dictionary<String,SopClass> _sopList = new Dictionary<String,SopClass>();");
			writer.WriteLine("");
			writer.WriteLine("        /// <summary>Override that displays the name of the SOP Class.</summary>");
			writer.WriteLine("        public override string ToString()");
			writer.WriteLine("        {");
			writer.WriteLine("            return this.Name;");
			writer.WriteLine("        }");
			writer.WriteLine("");
			writer.WriteLine("        public static IList<SopClass> GetRegisteredSopClasses()");
			writer.WriteLine("        {");
			writer.WriteLine("            return new List<SopClass>(_sopList.Values).AsReadOnly();");
			writer.WriteLine("        }");

			writer.WriteLine(""); 
			writer.WriteLine("        /// <summary>Retrieve a SopClass object associated with the Uid.</summary>");
			writer.WriteLine("        public static SopClass GetSopClass(String uid)");
			writer.WriteLine("        {");
			writer.WriteLine("            SopClass theSop;");
			writer.WriteLine("            if (!_sopList.TryGetValue(uid, out theSop))");
			writer.WriteLine("            {");
			writer.WriteLine("                var newSop = new SopClass(string.Format(\"Generated: '{0}'\", uid), uid, SopClassCategory.Uncategorized);");
			writer.WriteLine("                theSop = RegisterSopClass(newSop);");
			writer.WriteLine("            }"); 
			writer.WriteLine("            return theSop;");
			writer.WriteLine("        }");
			writer.WriteLine("");

			writer.WriteLine("        public static SopClass RegisterSopClass(SopClass sopClass)");
			writer.WriteLine("        {");
			writer.WriteLine("            SopClass theSop;");
			writer.WriteLine("            if (!_sopList.TryGetValue(sopClass.Uid, out theSop))");
			writer.WriteLine("                _sopList.Add(sopClass.Uid, theSop = sopClass);");
			writer.WriteLine("            return theSop;");
			writer.WriteLine("        }");

			writer.WriteLine("        static SopClass()");
			writer.WriteLine("        {");

			// Standard Sops
			iter = _sopList.GetEnumerator();

			while (iter.MoveNext())
			{
				var sopClass = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("            _sopList.Add(" + sopClass.VarName + "Uid, ");
				writer.WriteLine("                         " + sopClass.VarName + ");");
				writer.WriteLine("");
			}

			// Now, Meta Sops
			iter = _metaSopList.GetEnumerator();

			while (iter.MoveNext())
			{
				var sopClass = (SopClass) ((DictionaryEntry) iter.Current).Value;

				writer.WriteLine("            _sopList.Add(" + sopClass.VarName + "Uid, ");
				writer.WriteLine("                         " + sopClass.VarName + ");");
				writer.WriteLine("");
			}
			writer.WriteLine("        }");
			writer.WriteLine("");

			writer.WriteLine("    }");
			WriterFooter(writer);

			writer.Close();
		}
	}
}